/*
 * Copyright (C) 2015 Red Bull Media House GmbH <http://www.redbullmediahouse.com> - all rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.rbmhtechnology.eventuate

import java.util.function.{Function => JFunction}

import scala.collection.JavaConverters._
import scala.collection.immutable.Seq

import akka.actor._

object ReplicationConnection {
  /**
   * Default name of the remote actor system to connect to.
   */
  val DefaultRemoteSystemName: String = "location"

  /**
   * Creates [[ReplicationConnection]] with remote actor system `name` set to [[DefaultRemoteSystemName]].
   *
   * @param host host of the remote actor system that runs a [[ReplicationEndpoint]].
   * @param port port of the remote actor system that runs a [[ReplicationEndpoint]].
   * @param filters Replication filters applied remotely. Filters are applied to individual
   *                event logs where filter keys are the corresponding event log names.
   */
  def apply(host: String, port: Int, filters: Map[String, ReplicationFilter]): ReplicationConnection =
    new ReplicationConnection(host, port, filters = filters)

  /**
   * Creates [[ReplicationConnection]] with remote actor system `name` set to [[DefaultRemoteSystemName]]
   * and an optional replication `filter` applied to the event log with name [[ReplicationEndpoint.DefaultLogName]].
   *
   * @param host host of the remote actor system that runs a [[ReplicationEndpoint]].
   * @param port port of the remote actor system that runs a [[ReplicationEndpoint]].
   * @param filter Optional filter applied remotely. If defined, the filter is applied to
   *               the event log with name [[ReplicationEndpoint.DefaultLogName]].
   */
  def apply(host: String, port: Int, filter: Option[ReplicationFilter]): ReplicationConnection = filter match {
    case Some(f) => new ReplicationConnection(host, port, filters = Map(ReplicationEndpoint.DefaultLogName -> f))
    case None    => new ReplicationConnection(host, port)
  }
}

/**
 * A replication connection descriptor.
 *
 * @param host Host of the remote actor system that runs a [[ReplicationEndpoint]].
 * @param port Port of the remote actor system that runs a [[ReplicationEndpoint]].
 * @param name Name of the remote actor system that runs a [[ReplicationEndpoint]].
 * @param filters Replication filters applied remotely. Filters are applied to individual
 *                event logs where filter keys are the corresponding event log names.
 */
case class ReplicationConnection(host: String, port: Int, name: String = ReplicationConnection.DefaultRemoteSystemName, filters: Map[String, ReplicationFilter] = Map.empty)

object ReplicationEndpoint {
  /**
   * Default log name.
   */
  val DefaultLogName: String = "default"

  /**
   * Identifies a [[ReplicationEndpoint]] instance.
   *
   * @param uid Globally unique endpoint id.
   * @param iid Instance specific endpoint id. Unique within scope of `uid`.
   */
  case class InstanceId(uid: String, iid: Long) {

    /**
     * Returns `true` if `this` is a new instance (= incarnation) `id`.
     */
    def newIncarnationOf(id: InstanceId): Boolean =
      uid == id.uid && iid != id.iid
  }

  /**
   * Published to the actor system's event stream if a remote log is available.
   */
  case class Available(endpointId: String, logName: String)

  /**
   * Published to the actor system's event stream if a remote log is unavailable.
   */
  case class Unavailable(endpointId: String, logName: String)

  /**
   * Matches a string of format "<hostname>:<port>".
   */
  private object Address {
    def unapply(s: String): Option[(String, Int)] = {
      val hp = s.split(":")
      Some((hp(0), hp(1).toInt))
    }
  }

  /**
   * Creates a [[ReplicationEndpoint]] with a single event log with name [[DefaultLogName]]. The
   * replication endpoint id and replication connections must be configured as follows:
   *
   * {{{
   *   endpoint.id = "endpoint-id"
   *   endpoint.connections = ["host-1:port-1", "host-2:port-2", ..., "host-n:port-n"]
   * }}}
   *
   * @param logFactory Factory of log actor `Props`. The `String` parameter of the factory is a unique
   *                   log id generated by this endpoint. The log actor must be assigned this log id.
   */
  def apply(logFactory: String => Props)(implicit system: ActorSystem): ReplicationEndpoint = {
    val config = system.settings.config
    val connections = config.getStringList("endpoint.connections").asScala.toList.map {
      case Address(host, port) => ReplicationConnection(host, port)
    }
    apply(logFactory, connections)
  }

  /**
   * Creates a [[ReplicationEndpoint]] with a single event log with name [[DefaultLogName]]. The
   * replication endpoint idmust be configured as follows:
   *
   * {{{
   *   endpoint.id = "endpoint-id"
   * }}}
   *
   * @param logFactory Factory of log actor `Props`. The `String` parameter of the factory is a unique
   *                   log id generated by this endpoint. The log actor must be assigned this log id.
   * @param connections Replication connections to other replication endpoints.
   */
  def apply(logFactory: String => Props, connections: Seq[ReplicationConnection])(implicit system: ActorSystem): ReplicationEndpoint = {
    val config = system.settings.config
    val endpointId = config.getString("endpoint.id")
    new ReplicationEndpoint(endpointId, Set(DefaultLogName), logFactory, connections)(system)
  }

  /**
   * Java API.
   *
   * Creates a [[ReplicationEndpoint]] with a single event log with name [[DefaultLogName]]. The
   * replication endpoint id and replication connections must be configured as follows:
   *
   * {{{
   *   endpoint.id = "endpoint-id"
   *   endpoint.connections = ["host-1:port-1", "host-2:port-2", ..., "host-n:port-n"]
   * }}}
   *
   * @param logFactory Factory of log actor `Props`. The `String` parameter of the factory is a unique
   *                   log id generated by this endpoint. The log actor must be assigned this log id.
   */
  def create(logFactory: JFunction[String, Props], system: ActorSystem) =
    apply(id => logFactory.apply(id))(system)
}

/**
 * A replication endpoint connects to other replication endpoints for replicating events. Events are
 * replicated from the connected endpoints to this endpoint. To setup bi-directional replication, the
 * other replication endpoints must additionally setup replication connections to this endpoint.
 *
 * A replication endpoint manages one or more event logs. Event logs are indexed by name. Events are
 * replicated only between event logs with matching names.
 *
 * @param id Unique replication endpoint id.
 * @param logNames Names of the event logs managed by this replication endpoint.
 * @param logFactory Factory of log actor `Props`. The `String` parameter of the factory is a unique
 *                   log id generated by this endpoint. The log actor must be assigned this log id.
 * @param connections Replication connections to other replication endpoints.
 */
class ReplicationEndpoint(val id: String, logNames: Set[String], logFactory: String => Props, connections: Seq[ReplicationConnection])(implicit system: ActorSystem) {
  import ReplicationEndpoint._

  /**
   * Unique replication endpoint instance id. The `instanceId` is used to distinguish
   * between different incarnations of an endpoint with given id.
   */
  val instanceId: InstanceId =
    InstanceId(id, System.currentTimeMillis)

  /**
   * The log actors managed by this endpoint, indexed by their name.
   */
  val logs: Map[String, ActorRef] =
    logNames.map(logName => logName -> system.actorOf(logFactory(logId(logName)))).toMap

  /**
   * Remote endpoints connect to this `connector`.
   */
  private val connector: ActorRef =
    system.actorOf(Props(new ReplicationServerConnector(logs, logId, instanceId)), ReplicationServerConnector.name)

  /**
   * Returns the unique log id for given `logName`.
   */
  private def logId(logName: String): String =
    s"${id}-${logName}"

  connections.foreach {
    case ReplicationConnection(host, port, name, filters) =>
      var cfs = filters
      logNames.foreach { logName =>
        cfs.get(logName) match {
          case Some(f) => cfs += (logName -> SourceLogIdExclusionFilter(logId(logName)).and(f))
          case None    => cfs += (logName -> SourceLogIdExclusionFilter(logId(logName)))
        }
      }
      system.actorOf(Props(new ReplicationClientConnector(host, port, name, logs, cfs, instanceId)))
  }
}
