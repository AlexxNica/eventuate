.. _architecture:

------------
Architecture
------------

Event logs
----------

Eventuate applications store application-defined events in event-logs. An event log can be replicated across *locations* where each location has its own copy of events in a local event log. Replication occurs asynchronously over *replication connections* between *replication endpoints*.

.. figure:: images/architecture-1.png
   :figwidth: 70%

   Fig. 1

   An event log, replicated across locations A, B and C.

Events within a local log are totally ordered. This total order however is likely to differ among locations, as events can be written concurrently. The strongest ordering guarantee that can be given across locations is `causal ordering`_ [#]_ which is tracked with `vector clocks`_. Causal ordering is guaranteed to be consistent with total ordering in local event logs. 

A replication endpoint can also manage more than one local event log. Event logs are indexed by name and replication occurs only between logs of the same name. Logs with different names are isolated from each other which is the basis for scaling writes. Also, their distribution across locations may differ, as shown in the following figure.

.. figure:: images/architecture-2.png
   :figwidth: 70%

   Fig. 2

   Three replicated event logs. Log X (blue) is replicated across locations A, B and C. Log Y (red) is replicated across locations A and B and log Z (green) is replicated across locations A and C.

Event storage backends at individual locations are pluggable. A location that requires strong durability guarantees should use a storage backend that is (synchronously) replicated within that location, others may use a more lightweight, non-replicated storage backend in case of weaker durability requirements.

Event replication across locations is reliable. Should a location crash or the network partitions, replication automatically resumes when crashed location recovers and/or the partition heals. Built-in failure detectors inform applications about (un)availability of other locations. Replication endpoints also ensure that no duplicates are ever written to target event logs.

Replication connections can be configured with replication filters, so that only events matching one or more filter predicates are replicated. This is especially useful for smaller locations (for example, a mobile device) that only needs to exchange a subset of events with other locations.

Event-sourced actors
--------------------

Event-sourced actors produce events to and consume events from an event log. During *command processing* they usually validate external commands against internal state and, if validation succeeds, write one or more events to their event log. During *event processing* they consume events they have written and update internal state by handling these events. This is the main idea behind `event sourcing`_. When used in context of a `CQRS`_ architecture, event-sourced actors usually implement the command-side (C).

.. figure:: images/architecture-3.png
   :figwidth: 70%

   Fig. 3

   An event-sourced actor, producing events to and consuming events from an event log.

When an event-sourced actor is re-started, internal state is recovered by replaying events from its local event log. Since events in a local event log are totally ordered, event replay at a given location is deterministic. Event replay can also be started from a snapshot of internal state which is an optimization to reduce recovery times (not implemented yet but coming soon).

In addition to handling their own events, event-sourced actors can also handle events written by other event-sourced actors to the same event log. This enables `event collaboration`_ between actors (:ref:`arch-fig4`). A special form of event collaboration is state replication where actors of the same type consume the same events at different locations to re-construct state. Another example of event collaboration is a distributed business process where actors of different type collaborate by exchanging events to achieve a common goal.

.. _arch-fig4:

.. figure:: images/architecture-4.png
   :figwidth: 70%

   Fig. 4 

   Two event-sourced actors exchanging events over a distributed event log.

Event-sourced actors may also interact with external services by sending commands and processing replies. Commands can be sent with at-most-once or at-least-once delivery semantics, depending on the reliability requirements of an application. Replies from external services are usually processed like external commands which may result in further events to be written. This way, external services can be included into reliable, event-driven business processes controlled by event-sourced actors.

.. figure:: images/architecture-5.png
   :figwidth: 70%

   Fig. 5

   External service integration.

From a functional perspective, there’s no difference if event-sourced actors exchange events over a local event log or over a distributed event log. This is especially useful for testing purposes as it doesn’t require to setup a distributed log.

Event-sourced views
-------------------

Event-sourced views are a functional subset of event-sourced actors. They can only consume events from an event log but cannot produce new events. When used in context of a `CQRS`_ architecture, they implement the query-side (Q). 

Event-sourced processors
------------------------

An event-sourced processor consumes events from one event log, processes them with application-defined behavior (stateless or stateful) and produces processed events to another event log. Event-sourced processors can be used as gateways between otherwise partitioned event logs. They are not implemented yet.

Vector clocks
-------------

In the current system model, an event-sourced actor represents a lightweight “process” with its own consistency boundary. After having consumed an event e :sub:`i`, events e :sub:`i+1`, e :sub:`i+2`, ..., e :sub:`i+n`, generated by that actor, causally depend on e :sub:`i`. To track causality, each event-sourced actor maintains a vector clock which is used to timestamp written events. For any two events, applications can therefore determine if they are causally related or if they are concurrent by comparing their vector timestamps. 

Only events that are actually handled by an event-sourced actor contribute to its vector clock. This allows to keep vector clock sizes small, even if a large number of event-sourced actors is used. For example, if an application follows a one-\ aggregate_-per-actor design, vector clock sizes scale only with the (small) number of locations rather than the (large) number of aggregates.

CRDT services
-------------

Eventuate implements operation-based CRDTs (commutative replicated data types or CmRDTs) which can be accessed via `CRDT services`_. CRDT services ... (TODO: what is their function and advantage ...) and free applications from dealing with low-level details such as event-sourced actors and update operation events. New CmRDT types can be developed and integrated with the CRDT development framework.

Batching
--------

Eventuate heavily relies on batching to optimize read and write throughput. Batching is used in the following places:

...

Adapters
--------

...

.. _CQRS: http://martinfowler.com/bliki/CQRS.html
.. _CRDT services: https://krasserm.github.io/2015/02/17/Implementing-operation-based-CRDTs/

.. _vector clocks: http://en.wikipedia.org/wiki/Vector_clock
.. _causal ordering: http://krasserm.github.io/2015/01/13/event-sourcing-at-global-scale/#event-log
.. _event sourcing: http://martinfowler.com/eaaDev/EventSourcing.html
.. _event collaboration: http://martinfowler.com/eaaDev/EventCollaboration.html
.. _aggregate: http://martinfowler.com/bliki/DDD_Aggregate.html

.. [#] In the linked article, the term *site* is synonymous with *location*.


